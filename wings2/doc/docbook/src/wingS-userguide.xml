<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<book>
  <title>wingS User Guide</title>

  <bookinfo>
    <date>May 7, 2005</date>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <section>
      <title>Target Audience</title>

      <para>This document is intended to serve curious novices, developers
      using wingS, and developers willing to look into its internals. The
      further you progress in this document, the deeper you are getting to the
      core of wingS.</para>

      <para>Chapter 1 provides an introduction to the concepts of wingS.
      Chapter 2 takes you through a step-by-step tutorial on how to write a
      wingS application and make it fly. Once you decide to develop an
      application chapter 3 will lead you through the wingS tool- and mindset.
      Chapter 4 is an architectural orientation to aid in understanding how
      wingS works. It tries to fill in enough background information such that
      a newcomer will be able to quickly understand wingS source code and code
      examples since there is plenty of demo code that you can look at.</para>

      <para>For management-oriented information please refer to the "<ulink
      url="http://www.j-wings.org/tiki-index.php?page=Documentation">wingS
      Whitepaper</ulink>".</para>
    </section>

    <section>
      <title>Typographical Conventions</title>

      <para><code>session.Session</code> - a wingS class name (the org.wings
      part of the full name is elided, but subnames, as in this example are
      shown)</para>

      <para>"TODO" labels call out to you. Yes, you! Participate in the effort
      to build a first-class documentation, give something back! </para>
    </section>

    <section>
      <title>Credits</title>

      <para>Contributions to this documentation were provided by Ian Gardner,
      Volker Fritzsch, Benjamin Schmid, and Oliver Scheck.</para>
    </section>
  </preface>

  <chapter>
    <title>The Basics</title>

    <section>
      <title>The Swing in wingS</title>

      <para>TODO</para>

      <section>
        <title>MVC - Events and Listeners</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Widgets</title>

        <para>TODO</para>
      </section>
    </section>

    <section>
      <title>Web-related Concepts</title>

      <para>TODO</para>

      <section>
        <title>Servlet API</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Templates - Separating UI and Logic</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Style</title>

        <para>TODO</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>The 3-Step Quick Start</title>

    <para>TODO</para>

    <section>
      <title>Writing a wingS Frame</title>

      <para>TODO</para>
    </section>

    <section>
      <title>Preparing the web.xml File</title>

      <para>TODO</para>
    </section>

    <section>
      <title>Deployment in Servlet Container and Go!</title>

      <para>TODO</para>
    </section>
  </chapter>

  <chapter>
    <title>The Developer's Perspective</title>

    <para>This chapter presents what you need to know to develop with the
    wingS library.</para>

    <sect1>
      <title>Application Startup and Configuration</title>

      <para>TODO</para>
    </sect1>

    <sect1>
      <title>Frames and Top Level Components</title>

      <para>TODO</para>
    </sect1>

    <sect1>
      <title>Layout Managers</title>

      <para>TODO</para>
    </sect1>

    <sect1>
      <title>User Input</title>

      <para>Input to your wingS application comes in the form of state changes
      to the various widgets you have created, and in application events that
      you can listen to. To illustrate this we use the simplest case of a form
      which contains an entry field and a button.</para>

      <sect2>
        <title>Entry Field</title>

        <para>Recall that user input for entry fields must be contained in a
        <code>SForm</code>. The first task is to create the form and entry
        field (layout details omitted):<programlisting>SForm form = new SForm();
// ... add to top pane, add layout
// The following assumes a template layout, the names "W1", "W2" 
// identify layout components
SLabel label = new SLabel("Enter stuff:");
form.add(label, "W1");
STextField text = new STextField("initial value");
form.add(text, "W2");</programlisting></para>

        <para>The text field variable might be made a class member variable so
        that you can access it later to retrieve its contents:</para>

        <programlisting>String dataValue = text.getText();</programlisting>

        <para>Alternatively you might declare it as a local final variable,
        and access it from within a local closure callback, reacting to user
        input as shown in the next section.</para>
      </sect2>

      <sect2>
        <title>Listening to Events</title>

        <para>Most widgets provide various "listener" interfaces so that you
        can supply your own callbacks in order to handle these. Here we create
        a push button and register a callback to receive notification when the
        button is pushed. Note that the button is declared final so that we
        can access it within the callback, alternatively we could have made it
        a member variable</para>

        <programlisting>final SButton submit = new SButton("Search");
form.add(submit, "W3");
ActionListener al = new ActionListener() {
  public void actionPerformed(ActionEvent e) { ... }
};
submit.addActionListener(al);</programlisting>

        <para>In the above example the callback only receives events when the
        button is pushed. An alternative is to make the form the listener,
        since if the form is to have a "default" button (when the user hits
        the enter key) then it is the form which will be notified. In this
        case you would add the listener callback to the form instead of the
        button:</para>

        <programlisting>form.addActionListener(al);</programlisting>

        <para>The ActionEvent.getSource() will determine whether the event
        comes from the button or the form so you can use the following tests
        in your callback:</para>

        <programlisting>public void actionPerformed(ActionEvent e) {
  if(submit == e.getSource())
  // submit button pushed
  if(form == e.getSource())
  // user hit enter key
}</programlisting>

        <para>You can extract data from the text field as shown above with a
        call to STextField.getText().</para>
      </sect2>
    </sect1>

    <sect1>
      <title>CSS Style</title>

      <sect2>
        <title>Default Styles</title>

        <para>wingS makes heavy use of CSS styles. The default wingS
        distribution contains a file plaf/xhtml/css1/default.css which is the
        main stylesheet for all components. A related file
        plaf/xhtml/css1/default.properties configures the mapping between
        various components and their default style, among other things.</para>
      </sect2>

      <sect2>
        <title>Custom Styles</title>

        <para>As well as modifying the default styles, you can customise
        component's styles programmatically. An example of this is in the
        wingset demo. In this case the new styles are held in a global, static
        stylesheet file. Hence the stylesheet is added to the main frame to
        ensure it can apply to all components.</para>

        <programlisting>frame = new SFrame("WingSet");
frame.addHeader(new Link("stylesheet", 
                         null,
                         "text/css",
                         null, 
                         new ClasspathResource("/wingset/css/myapp.css",
                                               "text/css")));</programlisting>

        <para>The stylesheet contains various customised styles, in this case
        a custom table header:</para>

        <programlisting>.table_hdr  { 
  background-color: #FFCC99 
}</programlisting>

        <para>By using a call to
        <code>STable.setHeaderStyle("table_hdr")</code> the default table
        style is overriden. Note that all components have a
        <code>SComponent.setStyle()</code> method to override their CSS style
        class (i.e. the name for the CSS class which bundles together their
        display attributes). The individual display attributes are stored in a
        <code>AttributeSet</code> member. See for example
        <code>SComponent.setAttribute</code>().</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Sharing Resources Among Servlets</title>

      <para>Architectural requirements often suggest a break-up of a web
      application into multiple servlets. Sharing common resources can be
      achieved with the ServletContext interface's methods for handling
      attributes.</para>

      <para>To make a resource (any Java object) available across servlets use
      the setAttribute() method:</para>

      <para><programlisting>ServletContext context = SessionManager.getSession().getServletContext();
context.setAttribute("app.resource", new SharedResource());</programlisting>Within
      a second servlet use getAttribute() to retrieve a reference to the
      resource:</para>

      <para><programlisting>ServletContext context = SessionManager.getSession().getServletContext();
SharedResource resource = context.getAttribute("app.resource");</programlisting>Attention
      has to be paid to the attribute's namespace, as it might interfer with
      other servlets. Prefixing the package name is an advisable
      convention.</para>

      <para>The approach presented above particularily makes sense if you have
      decided to use a mixed approach of wingS and other Servlet API based
      components as <code>ServletContext</code> is a Servlet API
      interface.</para>
    </sect1>

    <sect1>
      <title>File Upload and Download</title>

      <sect2>
        <title>File Upload</title>

        <para>TODO</para>
      </sect2>

      <sect2>
        <title>File Download</title>

        <para>One way of providing a download is implementing your own Servlet
        with the Servlet API directly:</para>

        <para><programlisting>public class XLSServlet extends HttpServlet {

  protected void doGet(HttpServletRequest request, 
                       HttpServletResponse response)
      throws ServletException, IOException {

    doPost(request, response);
  }

  protected void doPost(HttpServletRequest request, 
                        HttpServletResponse response)
      throws ServletException, IOException {

    HSSFWorkbook sheet = HSSFWorkbook();
    response.setContentType("application/vnd.ms-excel");
    ServletOutputStream out = response.getOutputStream();
    out.write(sheet.toBytes()));
    response.flushBuffer();
  }
} </programlisting></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Back Button Navigation</title>

      <para>The back button was conceived in the very beginning of the web
      when static content prevailed. Today's web landscape is dramatically
      different. The majority of content is created dynamically and web
      applications bring state and transactions into play.</para>

      <para>As intuitive and helpful back button navigation is using static
      pages, web application developers often wish they could just
      disable<footnote>
          <para>It can not be disabled, but the effect of the back button can
          be mitigated by telling the browser not to cache responses and
          redirecting it to a page containing explanatory information.</para>
        </footnote> it. Yet, we developers have to live with users clicking on
      back whenever they please. And let's face it, putting a message "Do NOT
      click the back button!" is a miserable solution, manifesting the
      incapacity of the applications creator.</para>

      <para>Therefore wingS gives you the power to detect and control the
      behaviour of back button events. The approach relies on our epoch
      checking mechanism. It enables you to handle the browsers back button
      navigation in three different ways:<orderedlist>
          <listitem>
            <para><emphasis role="bold">Default behaviour</emphasis> - ignore
            requests from old views and redisplay just the current view</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Allow back navigation</emphasis> - do
            nothing on back navigation, allow manipulations and clicks on
            hand-selected components</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">Back navigation detection</emphasis> -
            advise the browser to reload the page on every back navigation and
            try to detect this event</para>
          </listitem>
        </orderedlist></para>

      <para>Let's take a look at the details.</para>

      <sect2>
        <title>Default Behaviour</title>

        <para>This mode is the default and safest way to cope with the browser
        back facility. It ensures that the user can only operate on the
        current view and is not able to perform any operations on expired
        views, which might lead to unexpected results.</para>

        <para>Let's look at a short example how frameworks like Apache Struts
        or Sun JSF might react. Suppose you were building an email application
        presenting a list of received emails with a delete button beneath each
        list entry. After clicking such a delete button, the application would
        present a confirmation dialog. If you had built your application in a
        way that the delete buttons referred to an index, a browser back click
        and click on another delete button would delete the wrong email! In
        the default configuration wingS avoids this by ignoring the last
        deletion click and it will just redisplay the first confirmation
        dialog.</para>

        <para>Please keep in mind, that you will be most likely using the HTTP
        POST operation to receive any form data from the browser. On pressing
        the back button this will typically display a query window, asking the
        user if he really wants to submit his last data again.</para>
      </sect2>

      <sect2>
        <title>Allow Back Navigation</title>

        <para>Another approach supported by wingS is to allow back navigation
        and support operations on hand-selected components. In this case three
        things must be triggered.<itemizedlist>
            <listitem>
              <para>Firstly, SForm needs to use HTTP GET to avoid the nagging
              confirmation dialog of the browsers on back navigations.</para>

              <para><code>form.setPostMethod(false);</code></para>
            </listitem>

            <listitem>
              <para>Secondly, disable page expiration. Otherwise every back
              navigation leads to a page reload presenting the current view
              again.</para>

              <para><code>form.getParentFrame().setNoCaching(true);</code></para>
            </listitem>

            <listitem>
              <para>Lastly, you have to disable the epoch checking on the
              desired components.</para>

              <para><code>anAlwaysValidComponent.setEpochCheckEnabled(false);</code></para>
            </listitem>
          </itemizedlist>On disabling the epoch check on a component you
        should be aware that consequently this component might receive input
        events at any time from developer's perspective. You must ensure that
        the action triggered will always lead to valid actions in your
        application. If you obey this you will be able to build web
        applications with the full comfort of modern web browsers and the
        comfort of object-oriented design.</para>
      </sect2>

      <sect2>
        <title>Back Navigation Detection</title>

        <para>The last technique implemented in wingS is to determine back
        navigations heuristically. Therefore the root <code>SFrame</code>
        offers a method to declare a virtual back button. But first we'll take
        a quick look behind the scenes. </para>

        <para>As mentioned wingS uses the epoch check feature to detect back
        operations. For this operation mode we do the following:<itemizedlist>
            <listitem>
              <para>Advise the browser to reload every page immediately
              (default).</para>

              <para><code>rootFrame.setNoCaching(false);</code></para>
            </listitem>

            <listitem>
              <para>Register a virtual back button.</para>

              <para><code>rootFrame.setBackButton(virtualBackButton);</code></para>
            </listitem>
          </itemizedlist></para>

        <para>To ensure that this feature will work reliable you should use a
        global <code>SForm</code> element contained in every page. This form
        component will have it's own epoch like all other input elements. As
        we advise the browser to refresh every page on each entry, a browser's
        back navigation will lead to an immediate reload of the last page.
        This last page will also contain the (expired) form component and
        therefore lead to an <code>InvalidLowLevelEvent</code>. Hence, the
        root frame will be notified about this
        <code>InvalidLowLevelEvent</code> and interpret this as a result of a
        back navigation event. After triggering the virtual back button all
        further <code>InvalidLowLevelEvent</code> will be ignored for a short
        period of time to avoid multiple triggers and/or false detected back
        navigations as a result of inadvertent double-clicks on the client
        side.</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title id="chapInsidewingS">Inside wingS</title>

    <section>
      <title>Session Management</title>

      <para>A "session" is a logical conversation between one particular web
      browser and the server. Recall that HTTP involves request-response
      conversations between the web browser and the server. A session can span
      multiple such request-response conversations, and in the wingS case will
      typically be initiated when the wingS application is started. It will be
      terminated when the application explicitly closes the session, the web
      browser is closed or the session times out. Due to the nature of HTTP
      the server cannot tell automatically that a web browser is no longer
      "interested" so it must fall back on using a timeout. For better
      security it is recommended to provide your wingS application with an
      explicit "logoff" command, and encourage your users to use it ! (You can
      do this with a call to session.Session.exit)</para>

      <para>The session is managed by the servlet container, usually by
      associating a cookie with the name "JSESSIONID" with the HTTP requests.
      The particular value of the cookie then identifies to which session the
      request belongs. This mapping is all part of the standard java servlet
      framework. This in turn delegates handling of each request to
      <code>session.WingServlet</code> - you will set up the mapping between
      your web application name and this class as part of your servlet
      container configuration. (See the servlet tag in web.xml in an example
      application)</para>

      <para>The main servlet class, <code>session.WingServlet</code>, handles
      requests directly for resources that do not change (e.g. static images),
      otherwise it creates a session.SessionServlet instance appropriately for
      each new session and and delegates to this. The sessions's
      session.SessionServlet is thus the main coordinator and router of events
      to your wingS application code. Each instance will be associated with an
      instance of your main application class (which you configured using the
      "init-param" named "wings.mainclass" in your servlet container
      configuration). It also creates a session.Session instance which holds
      some useful instance data as well as sharing the implementation burden
      with <code>session.SessionServlet</code>. This instance is also
      transiently associated with the thread which is processing the HTTP
      request (since this will not change for the duration of the request)
      using session.SessionManager so that you can conveniently retrieve the
      session from your own application code using:
      <code>SessionManager.getSession()</code></para>

      <para>The first task for <code>session.SessionServlet</code> is to
      extract any parameters from the HTTP request, since this is how visual
      components will notify of some action like a user pressing a button, and
      to then trigger the appropriate wingS events. This is the stage where
      your application code will receive callbacks for any action listeners
      that you have registered, and in turn drive your whole application's
      logic. This is handled by passing any HTTP request parameters to the
      session's <code>session.LowLevelEventDispatcher</code> instance.</para>

      <para>After delivering all events <code>session.SessionServlet</code>
      needs to deliver the externalised representation of the appropriate
      resource as the HTTP response. If the requested resource indicates that
      it is for the default resource, i.e. the top level frame of your
      application, then it looks for the topmost frame associated with the
      session and "displays" this. Otherwise the request will be for an
      explicit resource, probably this will have been generated automatically
      using the externalisation framework when "displaying" some sub-component
      of the user-interface. It is rare that you need to explicitly know how
      to address user interface components. (This is covered in more detail
      later in this document).</para>

      <para>There is a magic identifier "_" which can be used to force the
      display of the top-level frame. This is very useful for debugging, and
      also for navigation back to the "home page" of your application.</para>

      <para>Top level frames are derived from <code>SFrame</code>. The
      show/hide methods actually add/remove the frame from the collection
      maintained by <code>session.SessionServlet</code>. This is how you can
      switch the "main window" in your application. Hence you can keep
      multiple windows "in the background" by holding the instances in your
      main application class, and switch rapidly between them.</para>

      <para>Your main application instance will be garbage collected when the
      session finishes, and typically you will access any "top level"
      application objects via this instance. I.e. where in a normal
      application you might have global static variables, these would be
      member variables of your main application instance in a wingS
      application. You can of course still use global static variables, if
      that is what you intend, in which case they will have a lifetime that
      encompasses all sessions.</para>

      <para>If you need to integrate some other piece of web technology you
      can use the functionality of the standard java servlet
      <code>HttpServletRequest</code> and <code>HttpSession</code> classes to
      communicate any common data required by different modules by using named
      session attributes. This keeps the code decoupled. For example:</para>

      <programlisting>public void setSessionFoo(HttpServletRequest request, MyFoo foo) 
    throws ServletException {
  
  HttpSession session = request.getSession();
  session.setAttribute("MySharedFoo", foo);
}

public MyFoo getSessionHelper(HttpServletRequest request) 
    throws ServletException {
  
  HttpSession session = request.getSession();
  Object x = session.getAttribute("MySharedFoo");
  if (x == null)
    throw new ServletException( ... );
  return((MyFoo) x);
}</programlisting>
    </section>

    <section>
      <title>Resources</title>

      <para>Resources provide a bridge between the user interface components
      and the externalisation mechanism. This allows user interface components
      to focus on high level tasks such as responding to events and ignore the
      messy issue of how to render themselves. A resource must be able to do
      two key things, which are explicit in the base class declaration of
      Resource:</para>

      <itemizedlist>
        <listitem>
          <para>Be referred to by a URL, hence implements
          <code>URLResource</code></para>
        </listitem>

        <listitem>
          <para>Render itself onto the HTTP response stream, hence implements
          <code>Renderable</code></para>
        </listitem>
      </itemizedlist>

      <para>URLs can be entirely arbitrary, in which case use a <ulink
      url="http://www.j-wings.org/javadoc/org/wings/SimpleURL.html"><code>SimpleURL</code></ulink>
      (e.g. to refer to another web application), or they can be relative to
      your web application context in which case use a <code>RequestURL</code>
      (e.g. for a resource deployed under your web application deployment
      directory). For further options see <ulink
      url="http://www.j-wings.org/javadoc/org/wings/externalizer/AbstractExternalizeManager.html"><code>AbstractExternalizeManager</code></ulink>
      flags. Resources will choose the type which is most suitable for
      themselves.</para>

      <section>
        <title>Resource Types</title>

        <para>The following resource classes are provided by
        wingS:<itemizedlist>
            <listitem>
              <para><ulink
              url="http://www.j-wings.org/javadoc/org/wings/StaticResource.html"><code>StaticResource</code></ulink>
              - base class for components whose representation does not
              change, e.g. images. Much of the implementation can be put into
              this base class so it has methods to write the raw data and
              represent its URL.</para>

              <para><itemizedlist>
                  <listitem>
                    <para><ulink
                    url="http://www.j-wings.org/javadoc/org/wings/ClasspathResource.html"><code>ClasspathResource</code></ulink>
                    - a static resource that is loaded by a class loader. This
                    is useful when you want to jar up a bunch of resources
                    (e.g. images) along with your java classes for deployment
                    to the servlet container. You can then refer to them using
                    your class namespace, e.g.
                    "com/acme/myapp/prettypicture.jpeg". You may not need to
                    use this directly (wingS uses it for static stylesheets),
                    but you are very likely to need the derived
                    ResourceImageIcon class which is for static images, and
                    would in fact be required for a JPEG file.</para>
                  </listitem>

                  <listitem>
                    <para><ulink
                    url="http://www.j-wings.org/javadoc/org/wings/FileResource.html"><code>FileResource</code></ulink>
                    - a static resource wrapped around a file stream. If the
                    resource is an image then use the derived FileImageIcon,
                    which will try and deduce dimensions.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <para><ulink
              url="http://www.j-wings.org/javadoc/org/wings/StringResource.html"><code>StringResource</code></ulink>
              - use this if you already have the raw representation data of
              some static resource as a string.</para>
            </listitem>

            <listitem>
              <para><ulink
              url="http://www.j-wings.org/javadoc/org/wings/DynamicResource.html"><code>DynamicResource</code></ulink>
              - base class for components whose representation changes, i.e.
              most user interface widgets. Because of the dynamic nature the
              URL of these resources is not constant, it is forced to a unique
              value on each subsequent request by an "epoch counter". This
              allows wingS to check that a request is for the most current
              representation of a resource, which is also an important
              security feature.<itemizedlist>
                  <listitem>
                    <para><ulink
                    url="http://www.j-wings.org/javadoc/org/wings/script/DynamicScriptResource.html"><code>script.DynamicScriptResource</code></ulink>
                    - implements externalisation for dynamic javascript</para>
                  </listitem>

                  <listitem>
                    <para><ulink
                    url="http://www.j-wings.org/javadoc/org/wings/style/DynamicStyleSheetResource.html"><code>style.DynamicStyleSheetResource</code></ulink>
                    - implements externalisation for dynamic stylesheet</para>
                  </listitem>

                  <listitem>
                    <para><ulink
                    url="http://www.j-wings.org/javadoc/org/wings/DynamicCodeResource.html"><code>DynamicCodeResource</code></ulink>
                    - actually only used for SFrame components. Delegates
                    externalisation to the frame.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section>
        <title>Mapping Resources</title>

        <para>As mentioned above resources provide the bridge to
        externalisation and this means that all resources must be able to
        refer to each other, so all resources must be assigned an id that can
        eventually be used in a URL or HTML form, (see Resource.getId).
        However this is not as simple as generating a new random string for
        each new object since the different resources listed above need
        different strategies for how to be referenced. Hence this process is
        managed by different externalizer.ExternalizeManager instances. This
        class (and its base class
        <code>externalizer.AbstractExternalizeManager</code>) maintains the
        mapping between id and resource. This happens on-demand when
        Resource.getId is called, which in turn calls
        externalizer.AbstractExternalizeManager.externalize. Note that at this
        stage no HTML is written, it simply initialises the resource so that
        it can be addressed. Once this is done a
        <code>externalizer.ExternalizedResource</code> instance is used to
        hold various bits of information that will be needed for subsequent
        externalisation, such as MIME type and whether any special HTTP
        headers are needed.</para>

        <para>The final stage of externalisation (called from SessionServlet)
        will call on the appropriate externalizer.ExternalizeManager to write
        an externalised representation of the
        <code>externalizer.ExternalizedResource</code>. This is delegated to a
        externalizer.Externalizer implementation specific to the MIME type of
        the resource (since this is how HTTP identifies different resource
        data types).</para>

        <para>There is also a system-wide manager,
        <code>externalizer.SystemExternalizeManager</code>, which is used for
        resources which are not bound to a session (e.g. static files). The
        <code>session.WingsServlet</code> identifies these requests at an
        early stage since the resource id starts with a minus character
        ("-").</para>
      </section>
    </section>

    <section>
      <title>Delivering Events</title>

      <para>The wingS framework needs to understand user actions in the web
      browser, and then map these to user interface events in the code
      executing in the servlet container. Most of these events are derived
      from standard java SDK classes such as java.awt.AWTEvent. Recalling the
      limitations of HTTP, these events must be encoded in the HTTP request,
      either in the URL or in posted form data. Hence the first task for
      session.SessionServlet is to extract any parameters from the HTTP
      request, and pass these to the session's
      <code>session.LowLevelEventDispatcher</code> instance. This extracts
      encoded events then passes them on to any LowLevelEventListener
      instances which have registered interest - these will be the actual user
      interface widgets like buttons, lists and tables.</para>

      <para>The dispatcher does some initial decoding of the HTTP request
      parameters, for example, an additional value may be encoded into the
      HTTP request parameter name using a "_" seperator. It then passes the
      events on to the listeners using
      <code>LowLevelEventListener.processLowLevelEvent()</code>. The specific
      widget will then turn this "low level" event into something semantically
      meaningful like a button selection. Widget implementors have to go to
      some trouble to ensure that events fire in the correct order so events
      are categorised as<itemizedlist>
          <listitem>
            <para>Low level - the raw events from HTTP request</para>
          </listitem>

          <listitem>
            <para>Intermediate level - representing some kind of widget state
            change "in progress"</para>
          </listitem>

          <listitem>
            <para>High level - what you as a wingS API user are typically
            interested in</para>
          </listitem>
        </itemizedlist></para>

      <para>Conceptually this should be fairly clear, you will see lots of
      logic related to this if you dig around the code, but this is unlikely
      to conern you unless you are implementing your own widgets. The main
      challenge is that an HTTP request will deliver multiple changes all in
      one go, unlike a classical application where all events would be nicely
      serialised. Hence the dispatcher has to try and work out a sensible set
      of events to deliver, and to delay some state changes so that components
      do not end up in an inconsistent state due to the order in which events
      fire.</para>
    </section>

    <section>
      <title>Externalisation and Rendering</title>

      <para>Externalisation is the process of rendering the wingS user
      interface in the HTTP response to the web browser. As explained in the
      section on resources, the first stage is to make resources referenceable
      by assigning an id. The final stage, which this section describes, is to
      write the actual representation on to a stream.</para>

      <para>First the session.SessionServlet must create an output stream. It
      uses a factory instance, <code>io.DeviceFactory</code> to create the
      appropriate <code>io.Device</code> derived stream. You can configure
      your own device factory class using the "wings.device.factory"
      init-param of your wingS application servlet. This is a very useful hook
      for debugging the raw output.</para>

      <para>The session.SessionServlet locates the top-level frame, and then
      calls externalizer.ExternalizeManager.deliver on its
      externalizer.ExternalizedResource. This method sets up various HTTP
      headers appropriately for the kind of resource (e.g. MIME type, caching)
      and then it delegates to <code>externalizer.Externalizer.write()</code>.
      Different derived classes are used depending on resource type. For
      example images must be appropriately encoded in GIF or PNG format,
      whereas static and dynamic resources delegate to the interface
      <code>Renderable</code>. This is probably the simplest interface, but
      can have a very complicated implementation ! The majority of objects you
      are likely to be interested in externalise themselves via the
      <code>Renderable</code> interface.</para>
    </section>
  </chapter>

  <appendix>
    <title>Resources</title>

    <para>The wingS project is hosted by SourceForge at <ulink
    url="http://sourceforge.net/projects/j-wings">http://sourceforge.net/projects/j-wings</ulink>.
    Here you find the latest releases, the CVS repository, and our mailing
    lists.</para>

    <para>Project members on the mailing lists wingS-users and
    wingS-developers provide fast and thorough answers to your
    questions.</para>

    <para>Professional support for wingS is provided by <ulink
    url="http://www.mercatis.com">mercatis information
    technologies</ulink>.</para>
  </appendix>
</book>