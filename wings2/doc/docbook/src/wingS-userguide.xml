<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<book>
  <title>wingS User Guide</title>

  <preface>
    <title>Preface</title>

    <section>
      <title>Target Audience</title>

      <para>TODO: This paragraph has to be reworked.</para>

      <para>This document is intended as an architectural orientation to aid
      in understanding how wingS works. It is not a step-by-step tutorial on
      how to write a wingS application. Instead it tries to fill in enough
      background information such that a newcomer will be able to quickly
      understand wingS source code and code examples since there is plenty of
      demo code that you can look at. Basic user interface concepts are
      probably familiar to the reader. What however will be unfamiliar is the
      mechanism that wingS uses to deliver this as a java servlet API.</para>
    </section>

    <section>
      <title>Typographical Conventions</title>

      <para>session.Session - a wingS class name (the org.wings part of the
      full name is elided, but subnames, as in this example are shown)</para>

      <para>SessionManager.getSession() - source code fragment</para>
    </section>

    <section>
      <title>Credits</title>

      <para>Contributions to this documentation were provided by Ian Gardner,
      Volker Fritzsch, and Oliver Scheck.</para>
    </section>
  </preface>

  <chapter>
    <title>The Basics</title>

    <para>TODO</para>

    <section>
      <title>The Swing in wingS</title>

      <para>TODO</para>

      <section>
        <title>MVC - Events and Listeners</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Widgets</title>

        <para>TODO</para>
      </section>
    </section>

    <section>
      <title>Web-related Concepts</title>

      <para>TODO</para>

      <section>
        <title>Servlet API</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Templates - Separating UI and Logic</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Style</title>

        <para>TODO</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>The 3-Step Quick Start</title>

    <para>TODO</para>

    <section>
      <title>Writing a wingS Frame</title>

      <para>TODO</para>
    </section>

    <section>
      <title>Preparing the web.xml File</title>

      <para>TODO</para>
    </section>

    <section>
      <title>Deployment in Servlet Container and Go!</title>

      <para>TODO</para>
    </section>
  </chapter>

  <chapter>
    <title>The Developer's Perspective</title>

    <para>TODO</para>

    <sect1>
      <title>Application Startup and Configuration</title>

      <para>TODO</para>
    </sect1>

    <sect1>
      <title>Frames and Top Level Components</title>

      <para>TODO</para>
    </sect1>

    <sect1>
      <title>Layout Managers</title>

      <para>TODO</para>
    </sect1>

    <sect1>
      <title>User Input</title>

      <para>Input to your wingS application comes in the form of state changes
      to the various widgets you have created, and in application events that
      you can listen to. To illustrate this we use the simplest case of a form
      which contains an entry field and a button.</para>

      <sect2>
        <title>Entry Field</title>

        <para>Recall that user input for entry fields must be contained in a
        SForm. The first task is to create the form and entry field (layout
        details omitted):<programlisting>SForm form = new SForm();
// ... add to top pane, add layout
// The following assumes a template layout, the names "W1", "W2" 
// identify layout components
SLabel label = new SLabel("Enter stuff:");
form.add(label, "W1");
STextField text = new STextField("initial value");
form.add(text, "W2");</programlisting></para>

        <para>The text field variable might be made a class member variable so
        that you can access it later to retrieve its contents:</para>

        <programlisting>String dataValue = text.getText();</programlisting>

        <para>Alternatively you might declare it as a local final variable,
        and access it from within a local closure callback, reacting to user
        input as shown in the next section.</para>
      </sect2>

      <sect2>
        <title>Listening to Events</title>

        <para>Most widgets provide various "listener" interfaces so that you
        can supply your own callbacks in order to handle these. Here we create
        a push button and register a callback to receive notification when the
        button is pushed. Note that the button is declared final so that we
        can access it within the callback, alternatively we could have made it
        a member variable</para>

        <programlisting>final SButton submit = new SButton("Search");
form.add(submit, "W3");
ActionListener al = new ActionListener() {
  public void actionPerformed(ActionEvent e) { ... }
};
submit.addActionListener(al);</programlisting>

        <para>In the above example the callback only receives events when the
        button is pushed. An alternative is to make the form the listener,
        since if the form is to have a "default" button (when the user hits
        the enter key) then it is the form which will be notified. In this
        case you would add the listener callback to the form instead of the
        button:</para>

        <programlisting>form.addActionListener(al);</programlisting>

        <para>The ActionEvent.getSource() will determine whether the event
        comes from the button or the form so you can use the following tests
        in your callback:</para>

        <programlisting>public void actionPerformed(ActionEvent e) {
  if(submit == e.getSource())
  // submit button pushed
  if(form == e.getSource())
  // user hit enter key
}</programlisting>

        <para>You can extract data from the text field as shown above with a
        call to STextField.getText().</para>
      </sect2>
    </sect1>

    <sect1>
      <title>CSS Style</title>

      <sect2>
        <title>Default Styles</title>

        <para>wingS makes heavy use of CSS styles.  Whereever it is possible, 
        CSS is used in order to style elements, so users can develop custom
        styles themselves. The basic CSS Styles are (of course) very
        Swing-centric and should be overridden with custom styles.</para>
      </sect2>

      <sect2>
        <title>Custom Styles</title>

        <para>As well as modifying the default styles, you can customise
        component's styles programmatically. An example of this is in the
        wingset demo. In this case the new styles are held in a global, static
        stylesheet file. Hence the stylesheet is added to the main frame to
        ensure it can apply to all components.</para>

        <programlisting>frame = new SFrame("WingSet");
frame.addHeader(new Link("stylesheet", 
                         null,
                         "text/css",
                         null, 
                         new ClasspathResource("/wingset/css/myapp.css",
                                               "text/css")));</programlisting>

        <para>The stylesheet contains various customised styles, in this case
        a custom table header:</para>

        <programlisting>.table_hdr  { 
  background-color: #FFCC99 
}</programlisting>

        <para>By using a call to STable.setHeaderStyle("table_hdr") the
        default table style is overriden. Note that all components have a
        SComponent.setStyle()method to override their CSS style class (i.e.
        the name for the CSS class which bundles together their display
        attributes). The individual display attributes are stored in a
        AttributeSet member. See for example SComponent.setAttribute().</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Sharing Resources Among Servlets</title>

      <para>Architectural requirements often suggest a break-up of a web
      application into multiple servlets. Sharing common resources can be
      achieved with the ServletContext interface's methods for handling
      attributes. </para>

      <para>To make a resource (any Java object) available across servlets use
      the setAttribute() method:</para>

      <para><programlisting>ServletContext context = SessionManager.getSession().getServletContext();
context.setAttribute("app.resource", new SharedResource());</programlisting>Within
      a second servlet use getAttribute() to retrieve a reference to the
      resource:</para>

      <para><programlisting>ServletContext context = SessionManager.getSession().getServletContext();
SharedResource resource = context.getAttribute("app.resource");</programlisting>Attention
      has to be paid to the attribute's namespace, as it might interfer with
      other servlets. Prefixing the package name is an advisable
      convention.</para>

      <para>The approach presented above particularily makes sense if you have
      decided to use a mixed approach of wingS and other Servlet API based
      components as ServletContext is a Servlet API interface.</para>
    </sect1>

    <sect1>
      <title>File Upload and Download</title>

      <sect2>
        <title>File Upload</title>

        <para>TODO</para>
      </sect2>

      <sect2>
        <title>File Download</title>

        <para>One way of providing a download is to implement your own Servlet
        with the Servlet API directly:</para>

        <para><programlisting>public class XLSServlet extends HttpServlet {

  protected void doGet(HttpServletRequest request, 
                       HttpServletResponse response)
      throws ServletException, IOException {

    doPost(request, response);
  }

  protected void doPost(HttpServletRequest request, 
                        HttpServletResponse response)
      throws ServletException, IOException {

    HSSFWorkbook sheet = HSSFWorkbook();
    response.setContentType("application/x-msexcel");
    ServletOutputStream out = response.getOutputStream();
    out.write(sheet.toBytes()));
    response.flushBuffer();
  }
} </programlisting></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title id="chapInsidewingS">Inside wingS</title>

    <section>
      <title>Session Management</title>

      <para>A "session" is a logical conversation between one particular web
      browser and the server. Recall that HTTP involves request-response
      conversations between the web browser and the server. A session can span
      multiple such request-response conversations, and in the wingS case will
      typically be initiated when the wingS application is started. It will be
      terminated when the application explicitly closes the session, the web
      browser is closed or the session times out. Due to the nature of HTTP
      the server cannot tell automatically that a web browser is no longer
      "interested" so it must fall back on using a timeout. For better
      security it is recommended to provide your wingS application with an
      explicit "logoff" command, and encourage your users to use it ! (You can
      do this with a call to session.Session.exit)</para>

      <para>The session is managed by the servlet container, usually by
      associating a cookie with the name "JSESSIONID" with the HTTP requests.
      The particular value of the cookie then identifies to which session the
      request belongs. This mapping is all part of the standard java servlet
      framework. This in turn delegates handling of each request to
      session.WingServlet - you will set up the mapping between your web
      application name and this class as part of your servlet container
      configuration. (See the servlet tag in web.xml in an example
      application)</para>

      <para>The main servlet class, session.WingServlet, handles requests
      directly for resources that do not change (e.g. static images),
      otherwise it creates a session.SessionServlet instance appropriately for
      each new session and and delegates to this. The sessions's
      session.SessionServlet is thus the main coordinator and router of events
      to your wingS application code. Each instance will be associated with an
      instance of your main application class (which you configured using the
      "init-param" named "wings.mainclass" in your servlet container
      configuration). It also creates a session.Session instance which holds
      some useful instance data as well as sharing the implementation burden
      with session.SessionServlet. This instance is also transiently
      associated with the thread which is processing the HTTP request (since
      this will not change for the duration of the request) using
      session.SessionManager so that you can conveniently retrieve the session
      from your own application code using: SessionManager.getSession()</para>

      <para>The first task for session.SessionServlet is to extract any
      parameters from the HTTP request, since this is how visual components
      will notify of some action like a user pressing a button, and to then
      trigger the appropriate wingS events. This is the stage where your
      application code will receive callbacks for any action listeners that
      you have registered, and in turn drive your whole application's logic.
      This is handled by passing any HTTP request parameters to the session's
      session.LowLevelEventDispatcher instance.</para>

      <para>After delivering all events session.SessionServlet needs to
      deliver the externalised representation of the appropriate resource as
      the HTTP response. If the requested resource indicates that it is for
      the default resource, i.e. the top level frame of your application, then
      it looks for the topmost frame associated with the session and
      "displays" this. Otherwise the request will be for an explicit resource,
      probably this will have been generated automatically using the
      externalisation framework when "displaying" some sub-component of the
      user-interface. It is rare that you need to explicitly know how to
      address user interface components. (This is covered in more detail later
      in this document).</para>

      <para>There is a magic identifier "_" which can be used to force the
      display of the top-level frame. This is very useful for debugging, and
      also for navigation back to the "home page" of your application.</para>

      <para>Top level frames are derived from SFrame. The show/hide methods
      actually add/remove the frame from the collection maintained by
      session.SessionServlet. This is how you can switch the "main window" in
      your application. Hence you can keep multiple windows "in the
      background" by holding the instances in your main application class, and
      switch rapidly between them.</para>

      <para>Your main application instance will be garbage collected when the
      session finishes, and typically you will access any "top level"
      application objects via this instance. I.e. where in a normal
      application you might have global static variables, these would be
      member variables of your main application instance in a wingS
      application. You can of course still use global static variables, if
      that is what you intend, in which case they will have a lifetime that
      encompasses all sessions.</para>

      <para>If you need to integrate some other piece of web technology you
      can use the functionality of the standard java servlet
      HttpServletRequest and HttpSession classes to communicate any common
      data required by different modules by using named session attributes.
      This keeps the code decoupled. For example:</para>

      <programlisting>public void setSessionFoo(HttpServletRequest request, MyFoo foo) 
    throws ServletException {
  
  HttpSession session = request.getSession();
  session.setAttribute("MySharedFoo", foo);
}

public MyFoo getSessionHelper(HttpServletRequest request) 
    throws ServletException {
  
  HttpSession session = request.getSession();
  Object x = session.getAttribute("MySharedFoo");
  if (x == null)
    throw new ServletException( ... );
  return((MyFoo) x);
}</programlisting>
    </section>

    <section>
      <title>Resources</title>

      <para>Resources provide a bridge between the user interface components
      and the externalisation mechanism. This allows user interface components
      to focus on high level tasks such as responding to events and ignore the
      messy issue of how to render themselves. A resource must be able to do
      two key things, which are explicit in the base class declaration of
      Resource:</para>

      <itemizedlist>
        <listitem>
          <para>Be referred to by a URL, hence implements URLResource</para>
        </listitem>

        <listitem>
          <para>Render itself onto the HTTP response stream, hence implements
          Renderable</para>
        </listitem>
      </itemizedlist>

      <para>URLs can be entirely arbitrary, in which case use a SimpleURL
      (e.g. to refer to another web application), or they can be relative to
      your web application context in which case use a RequestURL (e.g. for a
      resource deployed under your web application deployment directory). For
      further options see AbstractExternalizeManager flags. Resources will
      choose the type which is most suitable for themselves.</para>

      <section>
        <title>Resource Types</title>

        <para>The following resource classes are provided by wingS:</para>

        <para><itemizedlist>
            <listitem>
              <para>StaticResource - base class for components whose
              representation does not change, e.g. images. Much of the
              implementation can be put into this base class so it has methods
              to write the raw data and represent its URL.</para>

              <para><itemizedlist>
                  <listitem>
                    <para>ClasspathResource - a static resource that is loaded
                    by a class loader. This is useful when you want to jar up
                    a bunch of resources (e.g. images) along with your java
                    classes for deployment to the servlet container. You can
                    then refer to them using your class namespace, e.g.
                    "com/acme/myapp/prettypicture.jpeg". You may not need to
                    use this directly (wingS uses it for static stylesheets),
                    but you are very likely to need the derived
                    ResourceImageIcon class which is for static images, and
                    would in fact be required for a JPEG file.</para>
                  </listitem>

                  <listitem>
                    <para>FileResource - a static resource wrapped around a
                    file stream. If the resource is an image then use the
                    derived FileImageIcon, which will try and deduce
                    dimensions.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <para>StringResource - use this if you already have the raw
              representation data of some static resource as a string.</para>
            </listitem>

            <listitem>
              <para>DynamicResource - base class for components whose
              representation changes, i.e. most user interface widgets.
              Because of the dynamic nature the URL of these resources is not
              constant, it is forced to a unique value on each subsequent
              request by an "epoch counter". This allows wingS to check that a
              request is for the most current representation of a resource,
              which is also an important security feature.<itemizedlist>
                  <listitem>
                    <para>script.DynamicScriptResource - implements
                    externalisation for dynamic javascript</para>
                  </listitem>

                  <listitem>
                    <para>style.DynamicStyleSheetResource - implements
                    externalisation for dynamic stylesheet</para>
                  </listitem>

                  <listitem>
                    <para>DynamicCodeResource - actually only used for SFrame
                    components. Delegates externalisation to the frame.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section>
        <title>Mapping Resources</title>

        <para>As mentioned above resources provide the bridge to
        externalisation and this means that all resources must be able to
        refer to each other, so all resources must be assigned an id that can
        eventually be used in a URL or HTML form, (see Resource.getId).
        However this is not as simple as generating a new random string for
        each new object since the different resources listed above need
        different strategies for how to be referenced. Hence this process is
        managed by different externalizer.ExternalizeManager instances. This
        class (and its base class externalizer.AbstractExternalizeManager)
        maintains the mapping between id and resource. This happens on-demand
        when Resource.getId is called, which in turn calls
        externalizer.AbstractExternalizeManager.externalize. Note that at this
        stage no HTML is written, it simply initialises the resource so that
        it can be addressed. Once this is done a
        externalizer.ExternalizedResource instance is used to hold various
        bits of information that will be needed for subsequent
        externalisation, such as MIME type and whether any special HTTP
        headers are needed.</para>

        <para>The final stage of externalisation (called from SessionServlet)
        will call on the appropriate externalizer.ExternalizeManager to write
        an externalised representation of the
        externalizer.ExternalizedResource. This is delegated to a
        externalizer.Externalizer implementation specific to the MIME type of
        the resource (since this is how HTTP identifies different resource
        data types).</para>

        <para>There is also a system-wide manager,
        externalizer.SystemExternalizeManager, which is used for resources
        which are not bound to a session (e.g. static files). The
        session.WingsServlet identifies these requests at an early stage since
        the resource id starts with a minus character ("-").</para>
      </section>
    </section>

    <section>
      <title>Delivering Events</title>

      <para>The wingS framework needs to understand user actions in the web
      browser, and then map these to user interface events in the code
      executing in the servlet container. Most of these events are derived
      from standard java SDK classes such as java.awt.AWTEvent. Recalling the
      limitations of HTTP, these events must be encoded in the HTTP request,
      either in the URL or in posted form data. Hence the first task for
      session.SessionServlet is to extract any parameters from the HTTP
      request, and pass these to the session's session.LowLevelEventDispatcher
      instance. This extracts encoded events then passes them on to any
      LowLevelEventListener instances which have registered interest - these
      will be the actual user interface widgets like buttons, lists and
      tables.</para>

      <para>The dispatcher does some initial decoding of the HTTP request
      parameters, for example, an additional value may be encoded into the
      HTTP request parameter name using a "_" seperator. It then passes the
      events on to the listeners using
      LowLevelEventListener.processLowLevelEvent. The specific widget will
      then turn this "low level" event into something semantically meaningful
      like a button selection. Widget implementors have to go to some trouble
      to ensure that events fire in the correct order so events are
      categorised as<itemizedlist>
          <listitem>
            <para>Low level - the raw events from HTTP request</para>
          </listitem>

          <listitem>
            <para>Intermediate level - representing some kind of widget state
            change "in progress"</para>
          </listitem>

          <listitem>
            <para>High level - what you as a wingS API user are typically
            interested in</para>
          </listitem>
        </itemizedlist></para>

      <para>Conceptually this should be fairly clear, you will see lots of
      logic related to this if you dig around the code, but this is unlikely
      to conern you unless you are implementing your own widgets. The main
      challenge is that an HTTP request will deliver multiple changes all in
      one go, unlike a classical application where all events would be nicely
      serialised. Hence the dispatcher has to try and work out a sensible set
      of events to deliver, and to delay some state changes so that components
      do not end up in an inconsistent state due to the order in which events
      fire.</para>
    </section>

    <section>
      <title>Externalisation and Rendering</title>

      <para>Externalisation is the process of rendering the wingS user
      interface in the HTTP response to the web browser. As explained in the
      section on resources, the first stage is to make resources referenceable
      by assigning an id. The final stage, which this section describes, is to
      write the actual representation on to a stream.</para>

      <para>First the session.SessionServlet must create an output stream. It
      uses a factory instance, io.DeviceFactory to create the appropriate
      io.Device derived stream. You can configure your own device factory
      class using the "wings.device.factory" init-param of your wingS
      application servlet. This is a very useful hook for debugging the raw
      output.</para>

      <para>The session.SessionServlet locates the top-level frame, and then
      calls externalizer.ExternalizeManager.deliver on its
      externalizer.ExternalizedResource. This method sets up various HTTP
      headers appropriately for the kind of resource (e.g. MIME type, caching)
      and then it delegates to externalizer.Externalizer.write. Different
      derived classes are used depending on resource type. For example images
      must be appropriately encoded in GIF or PNG format, whereas static and
      dynamic resources delegate to the interface Renderable. This is probably
      the simplest interface, but can have a very complicated implementation !
      The majority of objects you are likely to be interested in externalise
      themselves via the Renderable interface.</para>
    </section>
  </chapter>
</book>